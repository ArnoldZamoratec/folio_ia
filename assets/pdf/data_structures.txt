# Data Structures Reference Guide
# Arnold Albert Huamán Zamora

## Essential Data Structures

### 1. Arrays and Lists
**Time Complexities:**
- Access: O(1)
- Search: O(n)
- Insert: O(n)
- Delete: O(n)

**Use Cases:**
- Sequential data storage
- Random access needed
- Fixed or predictable size

### 2. Linked Lists
**Time Complexities:**
- Access: O(n)
- Search: O(n)
- Insert: O(1) at head
- Delete: O(1) at head

**Implementation:**
`python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def insert(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
`

### 3. Stacks (LIFO)
**Operations:**
- Push: O(1)
- Pop: O(1)
- Peek: O(1)

**Applications:**
- Function call stack
- Undo mechanisms
- Expression evaluation
- Backtracking algorithms

`python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        return self.items.pop() if self.items else None
    
    def peek(self):
        return self.items[-1] if self.items else None
`

### 4. Queues (FIFO)
**Operations:**
- Enqueue: O(1)
- Dequeue: O(1)
- Front: O(1)

**Applications:**
- BFS traversal
- Task scheduling
- Buffer management

### 5. Hash Tables
**Time Complexities:**
- Insert: O(1) average
- Delete: O(1) average
- Search: O(1) average

**Collision Resolution:**
- Chaining
- Open addressing
- Double hashing

`python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def hash(self, key):
        return hash(key) % self.size
    
    def insert(self, key, value):
        index = self.hash(key)
        self.table[index].append((key, value))
    
    def get(self, key):
        index = self.hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None
`

### 6. Binary Trees
**Types:**
- Binary Search Tree (BST)
- AVL Tree
- Red-Black Tree
- B-Tree

**BST Operations:**
- Search: O(log n) average, O(n) worst
- Insert: O(log n) average, O(n) worst
- Delete: O(log n) average, O(n) worst

`python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_helper(self.root, val)
    
    def _insert_helper(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_helper(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_helper(node.right, val)
            else:
                node.right = TreeNode(val)
`

### 7. Heaps
**Types:**
- Min Heap
- Max Heap

**Operations:**
- Insert: O(log n)
- Extract Min/Max: O(log n)
- Peek: O(1)

**Applications:**
- Priority queues
- Heap sort
- Dijkstra's algorithm

### 8. Graphs
**Representations:**
- Adjacency Matrix: O(V) space
- Adjacency List: O(V + E) space

**Traversals:**
- DFS: O(V + E)
- BFS: O(V + E)

`python
class Graph:
    def __init__(self):
        self.graph = {}
    
    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)
    
    def bfs(self, start):
        visited = set()
        queue = [start]
        visited.add(start)
        
        while queue:
            vertex = queue.pop(0)
            print(vertex, end=' ')
            
            for neighbor in self.graph.get(vertex, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
`

### 9. Tries (Prefix Trees)
**Operations:**
- Insert: O(m) where m is key length
- Search: O(m)
- Delete: O(m)

**Applications:**
- Autocomplete
- Spell checking
- IP routing

### 10. Advanced Structures
- **Segment Tree**: Range queries O(log n)
- **Fenwick Tree**: Prefix sums O(log n)
- **Disjoint Set (Union-Find)**: Near O(1) operations
- **Skip List**: Alternative to balanced trees

## Choosing the Right Data Structure

| Need | Use |
|------|-----|
| Fast lookup | Hash Table |
| Ordered data | BST, Heap |
| LIFO operations | Stack |
| FIFO operations | Queue |
| Hierarchical data | Tree |
| Relationships | Graph |
| Prefix matching | Trie |

## Performance Comparison

| Structure | Access | Search | Insert | Delete |
|-----------|--------|--------|--------|--------|
| Array | O(1) | O(n) | O(n) | O(n) |
| Linked List | O(n) | O(n) | O(1) | O(1) |
| Stack | O(n) | O(n) | O(1) | O(1) |
| Queue | O(n) | O(n) | O(1) | O(1) |
| Hash Table | N/A | O(1) | O(1) | O(1) |
| BST | O(log n) | O(log n) | O(log n) | O(log n) |
| Heap | N/A | O(n) | O(log n) | O(log n) |

---

 2026 Arnold Albert Huamán Zamora
Guía de Estructuras de Datos
